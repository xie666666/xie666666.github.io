{"meta":{"title":"明光禅院","subtitle":"斯是陋室 惟吾德馨","description":"this is description","author":"佛系青年","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"网易暴力裁员-老蒋巨靠谱","slug":"网易暴力裁员-老蒋巨靠谱","date":"2019-12-18T14:02:08.000Z","updated":"2019-12-18T14:54:59.361Z","comments":true,"path":"2019/12/18/网易暴力裁员-老蒋巨靠谱/","link":"","permalink":"http://yoursite.com/2019/12/18/网易暴力裁员-老蒋巨靠谱/","excerpt":"今天看到网易裁员的B站观点型up主老蒋巨靠谱的视频，为步入职场做准备 https://www.bilibili.com/video/av77107846","text":"今天看到网易裁员的B站观点型up主老蒋巨靠谱的视频，为步入职场做准备 https://www.bilibili.com/video/av77107846 以下是做的笔记： 1.不要和HR成为朋友以最坏的恶意推测对方，但不需要以咄咄逼人的姿态和HR沟通，没用，心里层面上不要对HR产生怜悯，(他们的策略动之以情) 2.强烈的留档意识工作成果内容，OA沟通记录，报销信息，绩效考核。对话全程录音。逆向思维即对方录音，要谨言慎行，如被对方找茬就不认可“如果讨论我的工作失误，请准备好关于我工作存在重大失误相关的证据，之后再谈”(每次找茬都很笃定地堵住可能会妥协) 不要轻易在任何法律文书上签字。口头承诺以再就业的公司好评为来交换少赔偿，绝不要同意先走离职程序再要好评和低赔偿。 和HR的沟通只能OA或者公司邮箱的邮件(最好抄送HR部门最高领导)如口头休年假而不走邮箱流程回来被裁了 3.谈判前详细了解劳动法并想好自己的底线和筹码包括劳动法，当地劳动局补充性的条文，咨询当地劳动仲裁机构或者劳动者保护机构 知识点：工资=工作天数/21.75，而不是30，法定节假日带薪 Up主的原则和底线： 重要的:工资赔偿，每月都要交社保 次要的:加班费，五险一金少缴 语言沟通捧对方，不会因社保低标准去劳动局，但最基本的要求都要满足 4.不要轻易动用核武器(黑料)5.劳动法还是倾向劳动者的，要有最基本的底气(劳动合同如果不敲定，工牌饭卡上岗证)黑心HR的套路： 顺口溜： 社会水太深，不要太天真上班防一手，被裁不用愁欲加之罪不要怕，有理有据行天下害人之心不可有，防人之心不可无和老板对话留录音，心里舆论都站理工作失误不轻认，新手上班需紧记任何文件需慎签，到时被坑塌了天N+1时需博弈，权衡利弊三思行！除了邮件和OA，口头承若都是灰套路口中有年假，先礼后兵才不假年轻被坑不要莽，冷静处理不法盲时刻关注劳动法，到时维权有国家持料很黑要慎报，玉石俱焚没好报劳动人民不弱小，劳动合同瞧一瞧劳三 二五不要怂，上班打卡才有用劳动仲裁是核武，不到绝路不要用遇事不要怕，我们有国家(〜￣△￣)〜 UP补充评论及网友评论","categories":[],"tags":[{"name":"职场","slug":"职场","permalink":"http://yoursite.com/tags/职场/"}]},{"title":"CSV文件","slug":"csv文件","date":"2019-12-15T14:31:18.000Z","updated":"2019-12-15T14:51:46.316Z","comments":true,"path":"2019/12/15/csv文件/","link":"","permalink":"http://yoursite.com/2019/12/15/csv文件/","excerpt":"CSV文件：Comma-Separated Values，中文叫，逗号分隔值或者字符分割值，其文件以纯文本的形式存储表格数据。该文件是一个字符序列，可以由任意数目的记录组成，记录间以某种换行符分割。每条记录由字段组成，字段间的分隔符是其他字符或者字符串。所有的记录都有完全相同的字段序列，相当于一个结构化表的纯文本形式。用文本文件、EXcel或者类似与文本文件的都可以打开CSV文件。","text":"CSV文件：Comma-Separated Values，中文叫，逗号分隔值或者字符分割值，其文件以纯文本的形式存储表格数据。该文件是一个字符序列，可以由任意数目的记录组成，记录间以某种换行符分割。每条记录由字段组成，字段间的分隔符是其他字符或者字符串。所有的记录都有完全相同的字段序列，相当于一个结构化表的纯文本形式。用文本文件、EXcel或者类似与文本文件的都可以打开CSV文件。 在爬虫中，可以把数据写入CSV文件，示例如下： 1234567import csv #需要导入库with open('data.csv','w') as fp: writer = csv.writer(fp)#先传入文件句柄 writer.writerow(['id','name','age'])#然后写入 writer.writerow(['10001','mike','20'])#按行写入 writer.writerow(['10002','Bob','22']) writer.writerow(['10003','Jordan','21']) 如果想修改列与列之间的分隔符，传入delimiter参数： 1234567import csv #需要导入库with open('data.csv','w') as fp: writer = csv.writer(fp,delimiter = '*')#delimiter只能是一个字节的字符 writer.writerow(['id','name','age'])#然后写入 writer.writerow(['10001','mike','20'])#按行写入 writer.writerow(['10002','Bob','22']) writer.writerow(['10003','Jordan','21']) 也可以先写标题，在写数据：注意:数据是一个列表，并且用writerows()方法 一般情况下，爬虫的数据以字典居多： 12345678910import csvwith open('data.csv','w') as fp: fieldnames = ['id','name','age'] #先定义字典里的key #用DictWriter（）方法，增加一个fieldnames writer = csv.DictWriter(fp,fieldnames = fieldnames,delimiter = '+') writer.writeheader()#先写入key #按照字典的方式写入 writer.writerow(&#123; 'id':'10001','name':'mike','age':'20'&#125;) writer.writerow(&#123; 'id':'10002','name':'Bob','age':'22'&#125;) writer.writerow(&#123; 'id':'10003','name':'Jordan','age':'21'&#125;) 读取CSV文件由两种方式：（1）第一种 12345import csvwith open('data.csv','r',encoding = 'utf8') as fp: reader = csv.reader(fp) for row in reader: print(row) （2）第二种 123import pandas as pd #需要导入pandas库df = pd.read_csv('data.csv')print(df)","categories":[],"tags":[]},{"title":"python学习日记（五）","slug":"python学习日记（五）","date":"2019-10-28T14:31:51.000Z","updated":"2019-10-31T13:19:31.697Z","comments":true,"path":"2019/10/28/python学习日记（五）/","link":"","permalink":"http://yoursite.com/2019/10/28/python学习日记（五）/","excerpt":"##","text":"##","categories":[],"tags":[]},{"title":"python学习日记（四）","slug":"python学习日记（四）","date":"2019-10-24T12:37:24.000Z","updated":"2019-10-31T14:24:51.910Z","comments":true,"path":"2019/10/24/python学习日记（四）/","link":"","permalink":"http://yoursite.com/2019/10/24/python学习日记（四）/","excerpt":"有道翻译的爬虫+煎蛋网图片下载先介绍主要的包： urllib.request, urllib.parse","text":"有道翻译的爬虫+煎蛋网图片下载先介绍主要的包： urllib.request, urllib.parse 1urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None) 主体部分1234567891011121314151617181920import urllib.requestimport urllib.parseimport json#有道翻译的url需要删去_ocontent=input(\"请输入需要翻译的英语\")url='http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule'data=&#123;&#125;data['i']=contentdata['from']= 'AUTO'data['to']='AUTO'data['smartresult']='dict'data['client']='fanyideskweb'data['salt']='15717288199466'data['sign']='12fc8fd46e9075f2c78cd47c4a6dbb20'data['ts']='1571728819946'data['bv']='e218a051a7336600dfed880d272c7d6f'data['doctype']='json'data['version']='2.1'data['keyfrom']='fanyi.web'data['action']= 'FY_BY_REALTlME' 电脑访问12345data=urllib.parse.urlencode(data).encode('utf-8')#解析，编码成utf-8形式,以便传给服务器response=urllib.request.urlopen(url,data)#向网站发送请求，得到'utf-8'形式的responsehtml=response.read().decode('utf-8')#读取，并解码成json格式target=json.loads(html)#loads装载得到字典形式print(\"得到翻译结果如下：%s\" %(target['translateResult'][0][0]['tgt'])) 更改Header伪装成人类用户，先介绍Request()12#对Request的参数可通过add_header(key,val)#添加headerclass urllib.request.Request(url, data=None,headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None) 123456789#head改变user-Agent选项，防止被服务器屏蔽head=&#123;&#125;head['User-Agent']='Opera/9.80 (Windows NT 6.0) Presto/2.12.388 Version/12.14'req=urllib.request.Request(url,data,head)#??response=urllib.request.urlopen(req)#向网站发送POST请求，得到'utf-8'形式的responsehtml=response.read().decode('utf-8')#读取，并解码成json格式target=json.loads(html)#loads装载得到字典形式print(\"得到翻译结果如下：%s\" %(target['translateResult'][0][0]['tgt'])) 设置延时再访问(time.sleep())123456789import timewhile True: #有道翻译的url需要删去_o content=input(\"您需要翻译的文本（输入q！退出程序）：\") if content=='q!': print('程序已退出') break ...... time.sleep(5)#延时五秒钟在进行下一个访问操作 代理(urllib.request)1、参数是一个字典{‘类型’,’代理ip：端口号’}1proxy_support=urllib.request.ProxyHandler(&#123;&#125;) 2、定制、创建一个opener（个人理解网址打开器）1opener=urllib.request.build_opener(proxy_support) 3、安装opener12urllib.request.install_opener(opener)#以后urllib.request.urlopen()都能自动使用代理 4、调用opener1opener.open(url) 代码： 12345678910111213141516import urllib.requestimport randomurl='https://www.jiumodiary.com'#随机选一个代理ip，获取网址https://ip.ihuan.me/iplist=['47.75.177.173:80','150.109.55.190','39.108.238.97']proxy_support=urllib.request.ProxyHandler(&#123;'http':random.choice(iplist)&#125;)#伪装成用户浏览opener=urllib.request.build_opener(proxy_support)opener.addheaders=[('User-Agent','Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36')]urllib.request.install_opener(opener)#安装opener,自动代理response=urllib.request.urlopen(url)html=response.read().decode('utf-8')print(html) 爬取网站图片练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import urllib.requestimport osimport random#代理访问url,返回'utf-8'编码格式的html,防止图片（编码格式'base64'）错误？？def url_open(url): #iplist=['39.137.69.6','47.110.130.152','36.25.243.51','183.146.213.157'] #proxy_support=urllib.request.ProxyHandler(&#123;'http':random.choice(iplist)&#125;) proxy_support=urllib.request.ProxyHandler(&#123;'http':'39.137.69.7'&#125;) opener=urllib.request.build_opener(proxy_support) opener.addheaders=[('User-Agent','Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36')] urllib.request.install_opener(opener)#安装opener,自动代理 response=urllib.request.urlopen(url) html=response.read() return html#返回不同页图片的网址标识def get_page(url): html=url_open(url).decode('utf-8') #a=html.find('current-comment-page')+len('current-comment-page\"&gt;[') #b=html.find(']',a) a=html.find('href=\"//jandan.net/ooxx/')+len('href=\"//jandan.net/ooxx/') b=html.find('==',a,a+255) print(html[a:b]) return html[a:b]#查找当前页的所有jpg格式图片地址并返回def find_imgs(url): html=url_open(url).decode('utf-8') img_addrs=[] a=html.find('img src=') while a!=-1: b=html.find('.jpg',a,a+255)#一个图片的网址一般不会超过255 if b!=1: img_addrs.append(html[a+9:b+4]) else: b=a+9 #查找下一个图片 a=html.find('img src=',b) for each in img_addrs: print(each) return img_addrs#输入存有图片网址的列表，保存这些照片def save_imgs(folder,img_addrs): for each in img_addrs: filename=each.split('/')[-1]#分割斜杠，取字典的倒数第一项 #filename=each with open(filename,'wb') as f: img=url_open('http:'+each) f.write(img)def download_picture(folder='mm_picture',pages=2):###原来page=10 #os.mkdir(folder) os.chdir(folder) url='http://jandan.net/ooxx/' page_str=str(get_page(url)) for i in range(pages): #page_url = url+'page-' + str(page_num) +'#comments'有点问题 #举个例子 page_url = url+ str(page_str)+'==#comments'######## print('图片页码网址为：'+page_url) #page_url = url+'MjAxOTEwMjct' + 'NA'+'==#comments' img_addrs = find_imgs(page_url) print('没问题') save_imgs(folder,img_addrs)if __name__=='__main__': download_picture() 运行结果 使用scrapy框架爬取http://www.dmoztools.net 生成scrapy_test项目 12pip install scrapyscrapy startproject scrapy_test 生成的默认文件结构 1234567891011121314scrapy_test │ scrapy.cfg │ └──scrapy_test │ item.py │ middlewares.py │ pipelines.py │ setting.py │ ├── spiders │ │ __init__.py │ │ │ └─── __pycache__ └─ __pycache__ item.py 123456789import scrapyclass DmozItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() title = scrapy.Field() link = scrapy.Field() desc = scrapy.Field() domz.py 12345678910111213141516import scrapy#继承spider类的dmoz爬虫类,提交给Scheduler，Request给downloaderclass DmozSpider(scrapy.Spider): name=\"dmoz\" allowed_dpmains=['dmoz.org']#爬取范围 start_urls=[ \"http://www.dmoztools.net/Computers/Programming/Languages/Python/Books/\", \"http://www.dmoztools.net/Computers/Programming/Languages/Python/Resources/\" ] #分析的方法，回调函数，获得response时启动 def parse(self,response): filename=response.url.split('/')[-2] with open(filename,'wb') as f: f.write(response.body) cmd中scrapy genspider 项目名称 域名scrapy genspider dmoz dmoz.org生成相应代码 读取基于Xpath和CSS的表达式机制：Scrapy Selectors xpath(),css()：传入各自表达式，返回对应的selector list extract()：序列化节点为Unicode字符串，返回list re()：根据正则表达式，返回list","categories":[],"tags":[]},{"title":"pyhton学习日记（三）","slug":"python学习日记（三）","date":"2019-10-19T02:58:22.000Z","updated":"2019-10-28T08:11:57.613Z","comments":true,"path":"2019/10/19/python学习日记（三）/","link":"","permalink":"http://yoursite.com/2019/10/19/python学习日记（三）/","excerpt":"容器类型的协议（啥玩意听不懂，先搁这）fromkey,getitem，iteration，generator总任务：创建一个数组类，且记录读取元素的次数","text":"容器类型的协议（啥玩意听不懂，先搁这）fromkey,getitem，iteration，generator总任务：创建一个数组类，且记录读取元素的次数 fromkey的用法向字典中加入元素，seq是字，value是赋给的值 123456789101112#语法：dict.fromkeys(seq[, value])seq = ('Google', 'Runoob', 'Taobao')dict = dict.fromkeys(seq)print \"新字典为 : %s\" % str(dict)dict = dict.fromkeys(seq, 10)print \"新字典为 : %s\" % str(dict)运行：新字典为 : &#123;'Google': None, 'Taobao': None, 'Runoob': None&#125;新字典为 : &#123;'Google': 10, 'Taobao': 10, 'Runoob': 10&#125; getitem的用处当实例对象通过[]运算符取值时，会调用它的方法getitem 123456789101112131415161718192021#语法： __getitem__(self,key)class DataBase: '''Python 3 中的类''' def __init__(self, id, address): '''初始化方法''' self.id = id self.address = address self.d = &#123;self.id: 1, self.address: \"192.168.1.1\", &#125; def __getitem__(self, key): # return self.__dict__.get(key, \"100\") return self.d.get(key, \"default\")#返回键值，没有就返回default运行：&gt;&gt;&gt;data = DataBase(1, \"192.168.2.11\")&gt;&gt;&gt;print(data[\"hi\"])default&gt;&gt;&gt;print(data[data.id])1 最终的模块（就是这么简单）123456789101112131415161718class CountList: def __init__(self,*args): self.values=[x for x in args] self.count=&#123;&#125;.fromkeys(range(len(self.values)),0) def __len__(self): return len(self.values) def __getitem__(self,key):#??get不行ma ? self.count[key]+=1 return self.values[key]运行：&gt;&gt;&gt; c1=CountList(1,3,5,7,9)&gt;&gt;&gt; c2=CountList(2,4,6,8,10)&gt;&gt;&gt; c1[1]3&gt;&gt;&gt; c1.count&#123;0: 0, 1: 1, 2: 0, 3: 0, 4: 0&#125; 迭代器iter，next 123456&gt;&gt;&gt; string='xyz'&gt;&gt;&gt; it iter(string)&gt;&gt;&gt; while True: try:print(next(it)) except StopIteration: break 生成器yeild个人理解为迭代器iter的一个停顿点，作用还不清楚 有道翻译的数据获取12345678910111213141516171819202122232425import urllib.requestimport urllib.parseimport json#有道翻译的url需要删去_ocontent=input(\"请输入需要翻译的英语\")url='http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule'data=&#123;&#125;data['i']=contentdata['from']= 'AUTO'data['to']='AUTO'data['smartresult']='dict'data['client']='fanyideskweb'data['salt']='15717288199466'data['sign']='12fc8fd46e9075f2c78cd47c4a6dbb20'data['ts']='1571728819946'data['bv']='e218a051a7336600dfed880d272c7d6f'data['doctype']='json'data['version']='2.1'data['keyfrom']='fanyi.web'data['action']= 'FY_BY_REALTlME'data=urllib.parse.urlencode(data).encode('utf-8')#解析，编码成utf-8形式,以便传给服务器response=urllib.request.urlopen(url,data)#向网站发送请求，得到'utf-8'形式的responsehtml=response.read().decode('utf-8')#读取，并解码成json格式target=json.loads(html)#loads装载得到字典形式print(\"得到翻译结果如下：%s\" %(target['translateResult'][0][0]['tgt']))","categories":[],"tags":[]},{"title":"python学习日记（二）","slug":"python学习日记（二）","date":"2019-10-14T11:26:48.000Z","updated":"2019-10-20T13:29:13.049Z","comments":true,"path":"2019/10/14/python学习日记（二）/","link":"","permalink":"http://yoursite.com/2019/10/14/python学习日记（二）/","excerpt":"构造析构，BIF，property，构造MyProperty，new运算符，设计计时器构造函数：委托构造在一个类中初始化其它类的init（self[,param1…]）函数","text":"构造析构，BIF，property，构造MyProperty，new运算符，设计计时器构造函数：委托构造在一个类中初始化其它类的init（self[,param1…]）函数 12345678910111213141516&gt;&gt;&gt; class Turtle: def __init__(self,x): self.num=x&gt;&gt;&gt; class Fish: def __init__(self,y): self.num=y&gt;&gt;&gt; class Pool: def __init__(self,x,y): self.turtle=Turtle(x)#包含其它类的初始化 self.fish=Fish(y) def printnum(self): print(\"池子里乌龟%d只，鱼%d只\" %(self.turtle.num,self.fish.num))&gt;&gt;&gt; pool=Pool(3,4)&gt;&gt;&gt; pool.printnum()池子里乌龟3只，鱼4只 12345678910class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") 一些BIF（内置函数）1234567891011121314151617&gt;&gt;&gt; isinstance(pool.fish,Fish)True&gt;&gt;&gt; class shark(Fish): pass&gt;&gt;&gt; issubclass(shark,Fish)True&gt;&gt;&gt; hasattr(pool,'fish')#attribute，属性True&gt;&gt;&gt; hasattr(pool,'fish.num')False&gt;&gt;&gt; hasattr(pool.fish,'num')True&gt;&gt;&gt; getattr(pool.fish,'num')4&gt;&gt;&gt; setattr(pool.fish,'num',3)&gt;&gt;&gt; getattr(pool.fish,'num')3 x=property(setparameter,getparameter.delparameter以后可直接更改x的名字而不用改parameter的各个构造函数 12345678910111213141516171819202122232425262728293031323334353637383940class example: def __init__(self,size): self.size=size def getsize(self): return self.size def setsize(self,x): self.size=x def delsize(self): del self.size x=property(getsize,setsize,delsize)#增改删查&gt;&gt;&gt; exam1=example(10)&gt;&gt;&gt; exam1.getsize()10&gt;&gt;&gt; exam1=example(18)&gt;&gt;&gt; exam1.getsize()18&gt;&gt;&gt; exam1.x#直接访问size18&gt;&gt;&gt; exam1.x=99#直接更改size&gt;&gt;&gt; exam1.x99&gt;&gt;&gt; del exam1.x#直接删除size#官方文档中还可以这样用class C: def __init__(self): self._x = None @property#修饰符 def x(self): \"\"\"I'm the 'x' property.\"\"\" return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x 在example类的基础上，自己设计MyProperty 1234567891011121314151617181920&gt;&gt;&gt; class MyProperty: def __init__(self=None,fget=None,fset=None,fdel=None): self.fget=fget self.fset=fset self.fdel=fdel def __get__(self,instance,owner): return self.fget(instance)#传进来x def __set__(self,instance,value): self.fset(instance,value) def __del__(self,instance): self.fdel(instance)运行：&gt;&gt;&gt; test=example(5)&gt;&gt;&gt; test.x5&gt;&gt;&gt; test.x=3&gt;&gt;&gt; test.x3&gt;&gt;&gt; test.size3 构造函数 new, init123456789#__new__, __init__&gt;&gt;&gt; class CapStr(str): def __new__(cls,string): string=string.upper() return str.__new__(cls,string)a=CapStr('hello world')&gt;&gt;&gt; a'HELLO WORLD' 运算符算术运算基础，以及子类return的误区 123456789101112&gt;&gt;&gt; class try_int(int): def __add__(self,other): return self+other#报错，相当于在return里接着进行self的加法，死循环 def __sub__(self,other): return self-otherRecursionError: maximum recursion depth exceeded&gt;&gt;&gt; class try_int(int): def __add__(self,other): return int(self)+int(other)#强制类型转换成父类int就不会报错了 def __sub__(self,other): return int(self)-int(other) 以下假设变量： a=10，b=20： 表头1 表头2 表头3 + 两个对象相加 30 - 得到负数或是一个数减去另一个数 -10 * 两个数相乘或是返回一个被重复若干次的字符串 200 / x除以y 0.5 % 返回除法的余数 0 ** 返回x的y次幂 10^20 // 返回商的整数部分（向下取整） 9//2=4,-9//2=-5 1234567891011121314151617181920212223```## 设计一个计时器先看下内置函数 __str（print返回str），__repr（直接返回，不需要print）```python&gt;&gt;&gt; class A(): def __int__(self): return 5 def __str__(self): return \"佛系青年\"&gt;&gt;&gt; a=A()&gt;&gt;&gt; print(a)佛系青年################为什么不管int的返回值呢？&gt;&gt;&gt; class B(): def __repr__(self): return \"佛系青年\"&gt;&gt;&gt; b=B()&gt;&gt;&gt; b佛系青年 基本组成：import time包（localtime，time）init初始化参数，str和repr设定返回的变量，start，stop，calculate计算时间差 123456789101112131415161718192021222324252627282930313233343536373839404142434445import time as tclass MyTimer(): # 无父类继承 #各个变量的初始化 def __init__(self): self.prompt = \"未开始计时\" self.lasted = []#tuple数组记录时间差 self.begin = 0#不能和函数名重复 self.end = 0 def __str__(self): return self.prompt __repr__ = __str__#??? # 开始计时 def start(self): self.start = t.localtime() print('开始计时...') # 结束计时 def stop(self): if self.begin==0: print(\"请先start()\") self.stop = t.localtime() self.calculate() print('计时结束!') #内部方法，计算运行时间 def calculate(self): self.lasted = [] self.prompt = '总共运行了：' #把end和begin忠 年月日时分秒 的差按位依次加到self.lasted的末位 for index in range(6): self.lasted.append(self.stop[index] - self.start[index]) self.prompt += str(self.lasted[index]) self.prompt+='秒' print(self.prompt)运行：&gt;&gt;&gt; timer=MyTimer()&gt;&gt;&gt; timer.start()开始计时...&gt;&gt;&gt; timer.stop()总共运行了：000002秒计时结束! 重写内置函数__add 123456789101112131415161718192021222324 #用于计算两段时间的和 def __add__(self,other): prompt = \"总共运行了：\" result=[] for index in range(6): result.append(self.lasted[index] + other.lasted[index]) if result[index]: prompt += (str(result[index]) + self.unit[index])#加上各个单位 print(prompt)&gt;&gt;&gt; t1=MyTimer()&gt;&gt;&gt; t1.start()开始计时...&gt;&gt;&gt; t1.stop()总共运行了：000004秒计时结束!&gt;&gt;&gt; t2=MyTimer()&gt;&gt;&gt; t2.start()开始计时...&gt;&gt;&gt; t2.stop()总共运行了：000003秒计时结束!&gt;&gt;&gt; t1+t2总共运行了：7秒 设计一个温度计实现华氏度与摄氏度的自动转换 1234567891011121314151617181920212223242526272829303132class Celsius: def __init__(self,value=26.0): self.value=value def __get__(self,instance,owner): return self.value def __set__(self,instance,value): self.value=float(value)class Fahenheit: def __get__(self,instance,owner): return instance.cel*1.8+32 def __set__(self,instance,value): instance.cel=(float(value)-32)/1.8class Temperature: cel=Celsius() fah=Fahenheit()运行：&gt;&gt;&gt; temp=Temperature()&gt;&gt;&gt; temp.cel26.0&gt;&gt;&gt; temp.fah78.80000000000001&gt;&gt;&gt; temp.fah=183&gt;&gt;&gt; temp.cel83.88888888888889&gt;&gt;&gt; temp.cel=20&gt;&gt;&gt; temp.fah68.0","categories":[],"tags":[]},{"title":"矩阵求导总结","slug":"矩阵求导总结","date":"2019-10-13T04:59:13.000Z","updated":"2019-10-13T08:46:58.449Z","comments":true,"path":"2019/10/13/矩阵求导总结/","link":"","permalink":"http://yoursite.com/2019/10/13/矩阵求导总结/","excerpt":"基本公式： 1234Y = A * X --&gt; DY/DX = A&apos;Y = X * A --&gt; DY/DX = AY = A&apos; * X * B --&gt; DY/DX = A * B&apos;Y = A&apos; * X&apos; * B --&gt; DY/DX = B * A&apos;","text":"基本公式： 1234Y = A * X --&gt; DY/DX = A&apos;Y = X * A --&gt; DY/DX = AY = A&apos; * X * B --&gt; DY/DX = A * B&apos;Y = A&apos; * X&apos; * B --&gt; DY/DX = B * A&apos; 行向量Y’对列向量X求导： 12dX&apos;/dX = Id(AX)&apos;/dX = A&apos; 列向量Y对行向量X’求导 1dY/dX&apos; = (dY&apos;/dX)&apos; 向量对向量求导: 向量积对列向量X求导 12345678注意与标量求导有点不同。d(UV&apos;)/dX = (dU/dX)V&apos; + U(dV&apos;/dX)d(U&apos;V)/dX = (dU&apos;/dX)V + (dV&apos;/dX)U&apos;重要结论：d(X&apos;A)/dX = (dX&apos;/dX)A + (dA/dX)X&apos; = IA + 0X&apos; = Ad(AX)/dX&apos; = (d(X&apos;A&apos;)/dX)&apos; = (A&apos;)&apos; = Ad(X&apos;AX)/dX = (dX&apos;/dX)AX + (d(AX)&apos;/dX)X = AX + A&apos;X 标量对向量求导:","categories":[],"tags":[]},{"title":"python学习日记(一)","slug":"python学习日记（一）","date":"2019-10-08T14:18:55.000Z","updated":"2019-10-13T05:25:32.152Z","comments":true,"path":"2019/10/08/python学习日记（一）/","link":"","permalink":"http://yoursite.com/2019/10/08/python学习日记（一）/","excerpt":"tuple元胞数组： 12345numl=set([1,2,3,4,5,3,1])temp=[]for each in num1: if each not in temp: temp.append(each) 函数嵌套：汉诺塔 PythonObj/IDLE练习/hanoi.py","text":"tuple元胞数组： 12345numl=set([1,2,3,4,5,3,1])temp=[]for each in num1: if each not in temp: temp.append(each) 函数嵌套：汉诺塔 PythonObj/IDLE练习/hanoi.py 12345678910def hanoi(n,x,y,z): if n==1: print(x,'--&gt;',z) else: hanoi(n-1,x,z,y)#前n-i个从X挪到Y print(x,'--&gt;',z)#第n个从X挪到Z hanoi(n-1,y,x,z)#前n-1个从Y挪到Zn=int(input(\"请输入汉诺塔的层数：\"))hanoin（n,'X','Y','Z') dic的使用： 12345dict1=dict((('a',10),('b',20),('c',30),('d',40),('e',50),('f',60))) type(('a',10)) dict2=dict(a=10,b=20) dict.fromkeys(range(12),'赞') dict. file的使用 123456789101112with open(\"C:/Users/10921/Desktop/1.txt\") as b:#默认rb二进制只读模式，且使用完毕自动删除b for line in b.readlines(): print (line)a=open(\"C:/Users/10921/Desktop/1.txt\",'rb+') for line in a.readlines(): print(line)a.closefile.read([size])#若无size默认返回整个文件file.readlines([size])for line in f:print line#通过迭代器访问f.write(\"hello\\n\")# 文件系统 12345678910111213import osos.getcwd()os.chdir(path)#改变目录listdir(path='.')#列出路径mkdir(path)removedirs(path)rename(old,new)system(command)#运行系统的shellos.curdir#当前目录 = .os.pardir#指代上一级目录 = ..os.sep#输出操作系统路径分隔符os.linesep#输出操作系统行终止符os.name#输出操作系统名称 永久存储：pickle包：pkl文件，dump，load 12345678910111213import pickleimport os#序列化对象，将对象list1保存到文件pickle_filewb中去my_list1 = [123,3.14,'小智',['another list']]pickle_filewb = open('my_list.pkl','wb')pickle.dump(my_list,pickle_filewb)pickle_filewb.close()#反序列化对象，将文件中的数据解析为一个python对象,file中有read()接口和readline()接口pickle_filerb=open('my_list.pkl','rb')pickle_filerb=open('my_list.pkl','rb')my_list2=pickle.load(pickle_filerb)os.system('del my_list.pkl')#删除 类和对象：self 123456789101112class Ball: def setName(self,name): self.name=name def kick(self): print(\"我叫%s,该死的，谁踢我\" %(self.name))#创建对象空间后再构造&gt;&gt;&gt; a=Ball()&gt;&gt;&gt; a.setName('王大锤')&gt;&gt;&gt; b=Ball()&gt;&gt;&gt; b.setName('谢大脚')&gt;&gt;&gt; a.kick()我叫王大锤,该死的，谁踢我 魔法方法(构造方法):| __init__(self,parame1,param2)```12345678910```python&gt;&gt;&gt; class Ball def __init__(self,name): self.name=name def kick(self): print(&quot;我叫%s,该死的，谁踢我&quot; %(self.name))&gt;&gt;&gt; d=Ball(&apos;王大锤&apos;)&gt;&gt;&gt; d.kick()我叫王大锤,该死的，谁踢我 公有私有变量的定义和调用 123456789101112131415&gt;&gt;&gt; class Person: __name='王大锤' def getName(self): return self.__name#前面双下划綫表示私有变量，不加默认公有&gt;&gt;&gt; p=Person()&gt;&gt;&gt; p.name#错误 Traceback (most recent call last): File \"&lt;pyshell#76&gt;\", line 1, in &lt;module&gt; p.name AttributeError: 'Person' object has no attribute 'name'&gt;&gt;&gt; p.getName()'王大锤'#还有一种方法可以直接得到私有变量 obj._类名__私有变量名&gt;&gt;&gt; p._Person__name'王大锤' 继承inherit语法： 1234567&gt;&gt;&gt; class Parent: def hello(self):&gt;&gt;&gt; class Child(Parent): pass&gt;&gt;&gt; c=Child()&gt;&gt;&gt; c.hello()正在调用父类方法。。。 1234567891011121314151617181920212223242526272829303132333435363738394041mudule:fish_inherit.pyimport random as rclass Fish: def __init__(self): self.x=r.randint(0,10) self.y=r.randint(0,10) def move(self): self.x -= 1 print('我的位置是：',self.x,self.y)class Goldfish(Fish): passclass Carp(Fish): passclass Salmon(Fish): passclass Shark(Fish): def __init__(self):#重写了__init__函数覆盖父类的构造函数，无self.x和self.y self.hungry=True def eat(self): if self.hungry: print('吃货的梦想就是天天有的吃^_^') self.hungry = False else: print('太饱了，吃不下了！')运行：&gt;&gt;&gt; goldfish=Goldfish()&gt;&gt;&gt; goldfish.move()我的位置是： 5 10&gt;&gt;&gt; shark=Shark()&gt;&gt;&gt; shark.eat()吃货的梦想就是天天有的吃^_^&gt;&gt;&gt; shark.move() Traceback (most recent call last): File \"&lt;pyshell#132&gt;\", line 1, in &lt;module&gt; shark.move() File \"E:/PythonObj/IDLE练习/fish继承.py\", line 9, in move self.x -= 1 AttributeError: 'Shark' object has no attribute 'x' 12 12","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"markdown基本语法","slug":"markdown基本语法","date":"2019-08-22T13:28:30.000Z","updated":"2019-12-18T14:33:49.887Z","comments":true,"path":"2019/08/22/markdown基本语法/","link":"","permalink":"http://yoursite.com/2019/08/22/markdown基本语法/","excerpt":"Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。","text":"Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 相比WYSIWYG编辑器 优点：1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点：1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持Markdown编辑模式。 还好，简书是支持Markdown编辑模式的。 标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题","categories":[],"tags":[]}]}